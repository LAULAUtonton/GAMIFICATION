<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate" />
  <meta http-equiv="Pragma" content="no-cache" />
  <meta http-equiv="Expires" content="0" />
  <title>THE PIT ‚Äî Games Station</title>
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@500;700;900&display=swap" rel="stylesheet">

  <style>
    :root{
      --bg1:#bfe7ff;
      --bg2:#0ea5e9;
      --bg3:#082f49;
      --ink:#0b1220;
      --panel:#ffffff;
      --card:#f0f9ff;
      --line:#7dd3fc;
      --brand:#0284c7;
      --ok:#16a34a;
      --bad:#ef4444;
      --warn:#f59e0b;
      --shadow: 0 22px 60px rgba(0,0,0,.35);
      --r: 22px;
    }
    *{box-sizing:border-box}
    body{
      margin:0;
      font-family: "Orbitron", system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      background:
        radial-gradient(1100px 700px at 20% -10%, rgba(255,255,255,.28), transparent 55%),
        radial-gradient(circle, var(--bg1) 0%, var(--bg2) 55%, var(--bg3) 100%);
      color:var(--ink);
      min-height:100vh;
      padding:14px;
    }

    .app{
      width:min(1200px, calc(100vw - 28px));
      margin:0 auto;
      background:var(--panel);
      border-radius:28px;
      box-shadow:var(--shadow);
      border:1px solid rgba(255,255,255,.35);
      overflow:hidden;
    }

    .topbar{
      padding:18px 18px 14px;
      background: rgba(255,255,255,.65);
      border-bottom:1px solid rgba(2,132,199,.18);
      backdrop-filter: blur(8px);
    }
    h1{
      margin:0;
      text-align:center;
      letter-spacing:2px;
      font-size:clamp(18px, 3.6vw, 30px);
      color:#083344;
    }
    .sub{
      margin:8px 0 0;
      text-align:center;
      color:#075985;
      font-size:12px;
      line-height:1.35;
      font-weight:700;
    }

    .screen{display:none; padding:16px 16px 18px}
    .screen.active{display:block}

    .grid{
      display:grid;
      grid-template-columns: repeat(auto-fit, minmax(260px, 1fr));
      gap:12px;
      margin-top:10px;
    }
    .card{
      background:var(--card);
      border:2px solid var(--line);
      border-radius:18px;
      padding:14px;
      display:flex;
      flex-direction:column;
      gap:10px;
      min-height:168px;
    }
    .card h3{
      margin:0;
      color:#083344;
      font-size:16px;
      letter-spacing:.4px;
    }
    .card p{
      margin:0;
      font-size:12px;
      color:#075985;
      line-height:1.5;
      font-weight:700;
    }
    .row{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      align-items:center;
      justify-content:space-between;
      margin-top:auto;
    }

    .btn{
      border:none;
      border-radius:14px;
      padding:12px 14px;
      font-weight:900;
      cursor:pointer;
      font-family: inherit;
      letter-spacing:.3px;
      transition: transform .08s ease, filter .12s ease;
      user-select:none;
    }
    .btn:hover{ filter:brightness(1.06) }
    .btn:active{ transform: translateY(1px) }
    .primary{ background: var(--brand); color:#fff; }
    .soft{ background:#ffffff; border:2px solid var(--line); color:#083344; }
    .disabled{ opacity:.55; cursor:not-allowed; }

    .gameHeader{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      align-items:center;
      justify-content:space-between;
      margin-bottom:10px;
    }
    .pillRow{
      display:flex;
      gap:8px;
      flex-wrap:wrap;
      align-items:center;
    }
    .pill{
      background:#e0f2fe;
      border:2px solid var(--line);
      border-radius:999px;
      padding:9px 11px;
      font-size:11px;
      font-weight:900;
      color:#083344;
      white-space:nowrap;
    }
    .info{
      width:100%;
      background:#e0f2fe;
      border:2px solid var(--line);
      border-radius:16px;
      padding:10px 12px;
      font-size:12px;
      font-weight:800;
      color:#075985;
      line-height:1.35;
    }

    .gameWrap{
      display:grid;
      grid-template-columns: minmax(0, 1fr) 320px;
      gap:12px;
      align-items:start;
      margin-top:10px;
    }

    .board{
      background:#020617;
      border:2px solid rgba(14,165,233,.95);
      border-radius:18px;
      padding:10px;
      display:grid;
      gap:3px;
      user-select:none;
      box-shadow: inset 0 0 0 1px rgba(56,189,248,.35), 0 0 22px rgba(14,165,233,.22);
      background-image:
        linear-gradient(rgba(56,189,248,.08) 1px, transparent 1px),
        linear-gradient(90deg, rgba(56,189,248,.08) 1px, transparent 1px);
      background-size: 24px 24px;
    }

    .cell{
      border-radius:10px;
      display:flex;
      align-items:center;
      justify-content:center;
      text-align:center;
      line-height:1.05;
      font-weight:900;
      padding:4px;
      border:1px solid rgba(125,211,252,.28);
      background: rgba(14,165,233,.06);
      color: rgba(255,255,255,.92);
      position:relative;
      overflow:hidden;
    }

    .cell.word{
      background: rgba(255,255,255,.07);
      border: 1px solid rgba(255,255,255,.22);
      color:#fff;
    }
    .cell.word.next{
      background: rgba(37,99,235,.38);
      border:2px solid #93c5fd;
      color:#ffffff;
      text-shadow:0 0 8px rgba(147,197,253,.95);
      box-shadow: inset 0 0 0 1px rgba(255,255,255,.3), 0 0 12px rgba(59,130,246,.8);
    }

    .cell.wall{
      background: rgba(59,130,246,.18);
      border-color: rgba(59,130,246,.20);
    }

    .cell{
      background-image: radial-gradient(circle, rgba(255,255,255,.45) 0 2px, transparent 3px);
      background-repeat:no-repeat;
      background-position:center;
    }
    .cell.wall,
    .cell.word,
    .cell.pac,
    .cell.ghost{ background-image:none; }


    .cell.pac::before{
      content:"";
      width: 34px;
      height: 36px;
      background:#2563eb;
      border-radius: 16px 16px 8px 8px;
      position:absolute;
      box-shadow: inset 0 -5px 0 0 #1d4ed8, 0 0 12px rgba(37,99,235,.65);
      clip-path: polygon(0 0,100% 0,100% 82%,86% 100%,72% 82%,58% 100%,44% 82%,30% 100%,16% 82%,0 100%);
      transform: translateY(0);
      animation: floaty .75s ease-in-out infinite;
    }
    .cell.pac::after{
      content:"‚óâ ‚óâ";
      position:absolute;
      top:14px;
      color:#dbeafe;
      font-size:11px;
      letter-spacing:1px;
      font-weight:900;
    }
    .cell.ghost::before{
      content:"";
      width: 32px;
      height: 34px;
      background: #facc15;
      border-radius: 16px 16px 8px 8px;
      position:absolute;
      box-shadow: inset 0 -5px 0 0 #ca8a04, 0 0 12px rgba(250,204,21,.55);
      clip-path: polygon(0 0,100% 0,100% 82%,86% 100%,72% 82%,58% 100%,44% 82%,30% 100%,16% 82%,0 100%);
    }
    .cell.ghost::after{
      content:"‚óâ ‚óâ";
      position:absolute;
      top:14px;
      color:#111827;
      font-size:11px;
      letter-spacing:1px;
      font-weight:900;
    }

    @keyframes floaty{
      0%,100%{ transform: translateY(0); }
      50%{ transform: translateY(-2px); }
    }

    .side{
      background: var(--card);
      border:2px solid var(--line);
      border-radius:18px;
      padding:12px;
    }
    .side h4{
      margin:0 0 10px;
      color:#083344;
      font-size:13px;
      letter-spacing:.6px;
      text-transform:uppercase;
    }
    .progressRow{
      display:flex;
      flex-wrap:wrap;
      gap:8px;
      margin:8px 0 10px;
    }
    .slot{
      min-width:40px;
      padding:10px 10px;
      border-radius:12px;
      border:1px dashed rgba(2,132,199,.35);
      background: rgba(255,255,255,.6);
      font-weight:1000;
      text-align:center;
      color: rgba(7,89,133,.75);
    }
    .slot.filled{
      border-style:solid;
      border-color: rgba(22,163,74,.45);
      background: rgba(22,163,74,.12);
      color:#083344;
    }

    .feedback{
      min-height:26px;
      font-size:12px;
      font-weight:1000;
      line-height:1.2;
      margin-top:8px;
      color:#075985;
    }
    .feedback.ok{ color: var(--ok); }
    .feedback.bad{ color: var(--bad); }
    .feedback.warn{ color: var(--warn); }

    .controls{
      display:grid;
      grid-template-columns: 1fr 1fr 1fr;
      gap:8px;
      max-width: 240px;
      margin-top:10px;
    }
    .controls .btn{ padding:10px 10px; border-radius:14px; }

    .miniRow{
      display:flex;
      gap:8px;
      flex-wrap:wrap;
      margin-top:10px;
    }

    .small{
      font-size:11px;
      color:#075985;
      font-weight:800;
      line-height:1.35;
      margin-top:10px;
    }

    @media (max-width: 980px){
      .gameWrap{ grid-template-columns: 1fr; }
    }
  </style>
</head>

<body>
  <main class="app">
    <header class="topbar">
      <h1>THE PIT ‚Äî GAMES STATION</h1>
      <p class="sub">
        Games menu for stations. Start with <b>PacSentence</b> (eat words and arrange sentences).
        Without showing the full order in advance.
      </p>
    </header>

    <section id="menuScreen" class="screen active">
      <div class="grid">
        <article class="card">
          <h3>üü¶ PacSentence (Arrange Sentences)</h3>
          <p>
            Use arrow keys or buttons. Eat words in the correct order.
            Large, readable words. No full-order hint (progress only).
          </p>
          <div class="row">
            <button id="startPacBtn" class="btn primary">Open game</button>
            <button id="menuHomeBtn" class="btn soft" onclick="location.href='../index.html'">Main menu</button>
          </div>
        </article>

        <article class="card">
          <h3>üöß Coming soon</h3>
          <p>Space for other games (Quiz, Matching, Wheel‚Ä¶). Keeping this file clean and stable.</p>
          <div class="row">
            <button class="btn soft disabled" disabled>Locked</button>
            <button class="btn soft disabled" disabled>Locked</button>
          </div>
        </article>
      </div>
    </section>

    <section id="pacScreen" class="screen">
      <div class="gameHeader">
        <div class="pillRow">
          <div class="pill">Time: <span id="timer">00:00</span></div>
          <div class="pill">Lives: <span id="lives">3</span></div>
          <div class="pill">Objective: <span id="nextWord">-</span></div>
          <div class="pill">Correct rounds: <span id="phrasesDone">0</span></div>
          <div class="pill">Status: <span id="statusText">In play</span></div>
          <div class="pill">Monster: <span id="ghostState">ON</span></div>
        </div>
        <div class="pillRow">
          <button id="backToMenu" class="btn soft">Back</button>
          <button id="restartGame" class="btn soft">Restart</button>
          <button id="nextSentence" class="btn primary">Next round</button>
        </div>
      </div>

      <div class="info" id="assignInfo">
        Game: PacSentence ¬∑ Auto-assigned skill: <b>Word order</b>
      </div>

      <div class="gameWrap">
        <div>
          <div id="board" class="board" aria-label="PacSentence board"></div>
          <p class="small">
            Instructions: move with <b>‚Üê ‚Üë ‚Üí ‚Üì</b> (or buttons), avoid the monster, and complete the round objective.
            Possible rounds: arrange a sentence, select all past-tense verbs, all adjectives, or all nouns.
          </p>
        </div>

        <aside class="side">
          <h4>Progress (without revealing the sentence)</h4>
          <div id="progressRow" class="progressRow"></div>

          <div id="feedback" class="feedback">Press ‚ÄúNext round‚Äù to start.</div>

          <div class="controls" aria-label="Controls">
            <span></span>
            <button class="btn soft" data-dir="up">‚Üë</button>
            <span></span>
            <button class="btn soft" data-dir="left">‚Üê</button>
            <button class="btn soft" data-dir="down">‚Üì</button>
            <button class="btn soft" data-dir="right">‚Üí</button>
          </div>

          <div class="miniRow">
            <button id="toggleGhosts" class="btn soft">Ghosts: ON</button>
            <button id="toggleReveal" class="btn soft">Show sentence (teacher): OFF</button>
          </div>

          <div class="small">
            <b>Teacher notes:</b><br>
            ‚Ä¢ ‚ÄúShow sentence (teacher)‚Äù displays the full sentence only in feedback (OFF by default).<br>
            ‚Ä¢ Edit the sentence bank in code: <b>ORDER_SENTENCES</b>.
          </div>
        </aside>
      </div>
    </section>
  </main>

<script>
(() => {
  const ORDER_SENTENCES = [
    "I read books at home.",
    "She likes music after class.",
    "We play soccer every Friday.",
    "They study English in teams.",
    "He drinks water before lunch.",
    "Birds can fly above trees.",
    "Open the door for me.",
    "Close your notebook right now."
  ];

  const CATEGORY_TASKS = [
    {
      prompt: "Select all past-tense verbs",
      words: ["played", "teacher", "happy", "walked", "city", "was"],
      targets: ["played", "walked", "was"]
    },
    {
      prompt: "Select all adjectives",
      words: ["beautiful", "table", "small", "ran", "blue", "dog"],
      targets: ["beautiful", "small", "blue"]
    },
    {
      prompt: "Select all nouns",
      words: ["book", "quickly", "teacher", "green", "school", "jumped"],
      targets: ["book", "teacher", "school"]
    }
  ];

  const GRID = 10;
  const TILE_PX = 64;
  const WALL_DENSITY = 0.12;

  const $ = (id) => document.getElementById(id);
  const screens = { menu: $("menuScreen"), pac: $("pacScreen") };

  const board = $("board");
  const feedback = $("feedback");
  const progressRow = $("progressRow");
  const timerEl = $("timer");
  const livesEl = $("lives");
  const nextWordEl = $("nextWord");
  const phrasesDoneEl = $("phrasesDone");
  const statusTextEl = $("statusText");
  const ghostStateEl = $("ghostState");
  const assignInfo = $("assignInfo");

  const state = {
    running: false,
    reveal: false,
    ghosts: true,
    grid: [],
    words: [],
    tokens: [],
    expected: 0,
    targetsSet: new Set(),
    foundTargets: new Set(),
    mode: "order",
    prompt: "",
    pac: {x: 0, y: 0, dir: "right"},
    ghost: {x: GRID-1, y: GRID-1},
    lives: 3,
    seconds: 0,
    timerRef: null,
    ghostRef: null,
    currentSentence: "",
    lastMoveAt: 0,
    phrasesDone: 0,
    statusText: "In play"
  };

  function shuffle(arr){
    for (let i = arr.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random()*(i+1));
      [arr[i], arr[j]] = [arr[j], arr[i]];
    }
    return arr;
  }
  function pad2(n){ return String(n).padStart(2,"0"); }
  function setScreen(name){ Object.values(screens).forEach(s => s.classList.remove("active")); screens[name].classList.add("active"); }
  function setFB(msg, cls=""){ feedback.className = "feedback" + (cls ? ` ${cls}` : ""); feedback.textContent = msg; }

  function updateHUD(){
    timerEl.textContent = `${pad2(Math.floor(state.seconds/60))}:${pad2(state.seconds%60)}`;
    livesEl.textContent = String(state.lives);
    nextWordEl.textContent = state.mode === "order" ? (state.tokens[state.expected] || "Done!") : state.prompt;
    phrasesDoneEl.textContent = String(state.phrasesDone);
    statusTextEl.textContent = state.statusText;
    ghostStateEl.textContent = state.ghosts ? "ON" : "OFF";
  }

  function updateAssign(){
    const skills = ["Word order", "Past-tense verbs", "Adjectives", "Nouns"];
    const pick = skills[Math.floor(Math.random()*skills.length)];
    assignInfo.innerHTML = `Game: PacSentence ¬∑ Auto-assigned skill: <b>${pick}</b>`;
  }

  function buildGrid(){
    const g = Array.from({length: GRID}, () => Array(GRID).fill(0));
    for (let x=0; x<GRID; x++){ g[0][x]=1; g[GRID-1][x]=1; }
    for (let y=0; y<GRID; y++){ g[y][0]=1; g[y][GRID-1]=1; }
    for (let y=1; y<GRID-1; y++) for (let x=1; x<GRID-1; x++){
      if ((x===1 && y===1) || (x===GRID-2 && y===GRID-2)) continue;
      if (Math.random() < WALL_DENSITY) g[y][x]=1;
    }
    for (let y=1; y<=2; y++) for (let x=1; x<=2; x++) g[y][x]=0;
    for (let y=GRID-3; y<=GRID-2; y++) for (let x=GRID-3; x<=GRID-2; x++) g[y][x]=0;
    state.grid = g;
  }

  function emptyCells(){
    const cells = [];
    for (let y=1; y<GRID-1; y++) for (let x=1; x<GRID-1; x++) if (state.grid[y][x] === 0) cells.push({x,y});
    return cells;
  }

  function makeRound(){
    const categoryMode = Math.random() < 0.45;
    if (categoryMode){
      const task = CATEGORY_TASKS[Math.floor(Math.random()*CATEGORY_TASKS.length)];
      state.mode = "category";
      state.prompt = task.prompt;
      state.currentSentence = task.prompt;
      state.tokens = [...task.words];
      state.targetsSet = new Set(task.targets);
      state.foundTargets = new Set();
      state.expected = 0;

      const items = shuffle(task.words.map(w => ({word:w, isTarget: state.targetsSet.has(w)})));
      const cells = shuffle(emptyCells().filter(c => !(c.x===1 && c.y===1) && !(c.x===GRID-2 && c.y===GRID-2)));
      state.words = items.slice(0, cells.length).map((it, i) => ({
        word: it.word, idx: -1, isCorrect: it.isTarget, eaten: false, x: cells[i].x, y: cells[i].y
      }));
      return;
    }

    const sentence = ORDER_SENTENCES[Math.floor(Math.random()*ORDER_SENTENCES.length)];
    state.mode = "order";
    state.prompt = "";
    state.currentSentence = sentence;
    state.tokens = sentence.trim().split(/\s+/);
    state.expected = 0;
    state.targetsSet = new Set();
    state.foundTargets = new Set();

    const pool = new Set();
    ORDER_SENTENCES.forEach(s => { if (s!==sentence) s.trim().split(/\s+/).forEach(w => pool.add(w)); });
    const distractors = shuffle([...pool]).slice(0, 2);
    const items = shuffle(state.tokens.map((w,i)=>({word:w, idx:i, isCorrect:true})).concat(distractors.map(w=>({word:w, idx:-1, isCorrect:false}))));
    const cells = shuffle(emptyCells().filter(c => !(c.x===1 && c.y===1) && !(c.x===GRID-2 && c.y===GRID-2)));
    state.words = items.slice(0, cells.length).map((it, i) => ({word:it.word, idx:it.idx, isCorrect:it.isCorrect, eaten:false, x:cells[i].x, y:cells[i].y}));
  }

  function buildProgress(){
    progressRow.innerHTML = "";
    const total = state.mode === "order" ? state.tokens.length : state.targetsSet.size;
    const done = state.mode === "order" ? state.expected : state.foundTargets.size;
    for (let i=0; i<total; i++){
      const d=document.createElement("div");
      d.className = "slot" + (i < done ? " filled" : "");
      d.textContent = i < done ? "‚úì" : "_";
      progressRow.appendChild(d);
    }
  }

  function render(){
    board.style.gridTemplateColumns = `repeat(${GRID}, 1fr)`;
    board.style.gridAutoRows = `${TILE_PX}px`;
    board.innerHTML = "";
    for (let y=0; y<GRID; y++) for (let x=0; x<GRID; x++){
      const cell = document.createElement("div");
      cell.className = "cell";
      if (state.grid[y][x] === 1) cell.classList.add("wall");
      const w = state.words.find(it => !it.eaten && it.x===x && it.y===y);
      if (w){
        cell.classList.add("word");
        if (state.mode === "order" && w.isCorrect && w.idx === state.expected) cell.classList.add("next");
        if (state.mode === "category" && w.isCorrect) cell.classList.add("next");
        const text = w.word;
        cell.textContent = text.length > 12 ? text.slice(0,12) : text;
        cell.style.fontSize = text.length <= 9 ? "19px" : "16px";
      }
      if (state.ghosts && state.ghost.x===x && state.ghost.y===y){ cell.classList.add("ghost"); cell.textContent = ""; }
      if (state.pac.x===x && state.pac.y===y){ cell.classList.add("pac"); cell.textContent = ""; }
      board.appendChild(cell);
    }
  }

  function stopLoops(){ clearInterval(state.timerRef); clearInterval(state.ghostRef); state.timerRef=null; state.ghostRef=null; }
  function startLoops(){
    stopLoops();
    state.timerRef = setInterval(() => { if(!state.running) return; state.seconds++; updateHUD(); }, 1000);
    state.ghostRef = setInterval(() => { if(!state.running || !state.ghosts) return; moveGhost(); checkCollision(); render(); }, 980);
  }

  function resetPositions(){ state.pac = {x:1,y:1,dir:"right"}; state.ghost = {x:GRID-2,y:GRID-2}; }

  function startGame(){
    updateAssign(); buildGrid(); resetPositions();
    state.seconds=0; state.lives=3; state.phrasesDone=0; state.statusText="In play"; state.running=true;
    makeRound(); buildProgress(); updateHUD(); render();
    setFB("Start: complete the round objective and avoid the monster.", "ok");
    startLoops();
  }

  function nextSentence(){
    buildGrid(); resetPositions(); state.seconds=0; state.statusText="In play"; state.running=true;
    makeRound(); buildProgress(); updateHUD(); render();
    setFB("New round started.", "ok");
  }

  function move(dir){
    if (!state.running) return;
    const now = Date.now(); if (now - state.lastMoveAt < 85) return; state.lastMoveAt = now;
    const v = {up:[0,-1],down:[0,1],left:[-1,0],right:[1,0]}[dir]; if (!v) return;
    state.pac.dir = dir;
    const nx = state.pac.x + v[0], ny = state.pac.y + v[1];
    if (state.grid[ny]?.[nx] === 1) { render(); return; }
    state.pac.x = nx; state.pac.y = ny;
    eatIfWord(); checkCollision(); render();
  }

  function finishRound(){
    state.running=false; stopLoops(); state.phrasesDone++; state.statusText="Round completed"; updateHUD();
    if (state.reveal) setFB(`üèÜ Completed: ${state.currentSentence}`, "ok");
    else setFB("üèÜ Correct! Press ‚ÄúNext round‚Äù.", "ok");
  }

  function eatIfWord(){
    const item = state.words.find(w => !w.eaten && w.x===state.pac.x && w.y===state.pac.y); if (!item) return;

    if (state.mode === "order"){
      const expected = state.tokens[state.expected];
      if (item.isCorrect && item.idx === state.expected && item.word === expected){
        item.eaten = true; state.expected++; buildProgress(); updateHUD();
        if (state.expected >= state.tokens.length) return finishRound();
        setFB("‚úÖ Correct. Continue with the highlighted word.", "ok");
      } else {
        item.eaten = true; state.lives--; updateHUD();
        if (state.lives <= 0){ state.running=false; stopLoops(); state.statusText="You lost"; updateHUD(); setFB("üíÄ No lives left. Press Restart.", "bad"); }
        else setFB(`‚ùå Incorrect. You needed: ${expected}`, "bad");
      }
      return;
    }

    if (item.isCorrect){
      item.eaten = true;
      state.foundTargets.add(item.word + '|' + state.pac.x + '|' + state.pac.y);
      buildProgress();
      if (state.foundTargets.size >= state.targetsSet.size) return finishRound();
      setFB("‚úÖ Correct. Keep finding target words.", "ok");
    } else {
      item.eaten = true; state.lives--; updateHUD();
      if (state.lives <= 0){ state.running=false; stopLoops(); state.statusText="You lost"; updateHUD(); setFB("üíÄ No lives left. Press Restart.", "bad"); }
      else setFB("‚ùå That word does not belong to the target category.", "bad");
    }
  }

  function moveGhost(){
    const dx = state.pac.x - state.ghost.x, dy = state.pac.y - state.ghost.y;
    let stepX=0, stepY=0;
    if (Math.abs(dx) >= Math.abs(dy) && dx !== 0) stepX = Math.sign(dx); else if (dy !== 0) stepY = Math.sign(dy);
    const candidates = [
      {x: state.ghost.x + stepX, y: state.ghost.y + stepY},
      {x: state.ghost.x + Math.sign(dx), y: state.ghost.y},
      {x: state.ghost.x, y: state.ghost.y + Math.sign(dy)},
      {x: state.ghost.x + 1, y: state.ghost.y}, {x: state.ghost.x - 1, y: state.ghost.y},
      {x: state.ghost.x, y: state.ghost.y + 1}, {x: state.ghost.x, y: state.ghost.y - 1},
    ];
    for (const c of candidates){ if (c.x<1 || c.y<1 || c.x>GRID-2 || c.y>GRID-2) continue; if (state.grid[c.y][c.x] === 1) continue; state.ghost=c; return; }
  }

  function checkCollision(){
    if (!state.running || !state.ghosts) return;
    if (state.pac.x === state.ghost.x && state.pac.y === state.ghost.y){
      state.lives--; updateHUD();
      if (state.lives <= 0){ state.running=false; stopLoops(); state.statusText="Monster caught you"; updateHUD(); setFB("üëª The monster caught you. Press Restart.", "bad"); }
      else { state.pac={x:1,y:1,dir:"right"}; setFB("üëª The monster touched you. You lose 1 life.", "warn"); }
    }
  }

  $("startPacBtn").addEventListener("click", () => { setScreen("pac"); startGame(); });
  $("backToMenu").addEventListener("click", () => { state.running=false; stopLoops(); setScreen("menu"); });
  $("restartGame").addEventListener("click", () => startGame());
  $("nextSentence").addEventListener("click", () => nextSentence());

  $("toggleGhosts").addEventListener("click", () => {
    state.ghosts = !state.ghosts;
    $("toggleGhosts").textContent = `Ghosts: ${state.ghosts ? "ON" : "OFF"}`;
    state.statusText = state.ghosts ? "In play" : "No monster";
    updateHUD(); render();
    setFB(state.ghosts ? "Ghosts enabled." : "Ghosts disabled.", "warn");
  });

  $("toggleReveal").addEventListener("click", () => {
    state.reveal = !state.reveal;
    $("toggleReveal").textContent = `Show sentence (teacher): ${state.reveal ? "ON" : "OFF"}`;
    setFB(state.reveal ? "Show sentence ON (sentence appears in feedback)." : "Show sentence OFF.", "warn");
  });

  document.querySelectorAll("[data-dir]").forEach(btn => btn.addEventListener("click", () => move(btn.dataset.dir)));
  window.addEventListener("keydown", (e) => {
    const map = {ArrowUp:"up", ArrowDown:"down", ArrowLeft:"left", ArrowRight:"right", w:"up", W:"up", s:"down", S:"down", a:"left", A:"left", d:"right", D:"right"};
    if (!map[e.key]) return; e.preventDefault(); move(map[e.key]);
  });

  setFB("Open PacSentence from the menu to play.", "");
  updateHUD();
})();
</script>
</body>
</html>
