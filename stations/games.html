<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate" />
  <meta http-equiv="Pragma" content="no-cache" />
  <meta http-equiv="Expires" content="0" />
  <title>THE PIT ‚Äî Games Station</title>
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@500;700;900&display=swap" rel="stylesheet">

  <style>
    :root{
      --bg1:#bfe7ff;
      --bg2:#0ea5e9;
      --bg3:#082f49;
      --ink:#0b1220;
      --panel:#ffffff;
      --card:#f0f9ff;
      --line:#7dd3fc;
      --brand:#0284c7;
      --ok:#16a34a;
      --bad:#ef4444;
      --warn:#f59e0b;
      --shadow: 0 22px 60px rgba(0,0,0,.35);
      --r: 22px;
    }
    *{box-sizing:border-box}
    body{
      margin:0;
      font-family: "Orbitron", system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      background:
        radial-gradient(1100px 700px at 20% -10%, rgba(255,255,255,.28), transparent 55%),
        radial-gradient(circle, var(--bg1) 0%, var(--bg2) 55%, var(--bg3) 100%);
      color:var(--ink);
      min-height:100vh;
      padding:14px;
    }

    .app{
      width:min(1200px, calc(100vw - 28px));
      margin:0 auto;
      background:var(--panel);
      border-radius:28px;
      box-shadow:var(--shadow);
      border:1px solid rgba(255,255,255,.35);
      overflow:hidden;
    }

    /* Header */
    .topbar{
      padding:18px 18px 14px;
      background: rgba(255,255,255,.65);
      border-bottom:1px solid rgba(2,132,199,.18);
      backdrop-filter: blur(8px);
    }
    h1{
      margin:0;
      text-align:center;
      letter-spacing:2px;
      font-size:clamp(18px, 3.6vw, 30px);
      color:#083344;
    }
    .sub{
      margin:8px 0 0;
      text-align:center;
      color:#075985;
      font-size:12px;
      line-height:1.35;
      font-weight:700;
    }

    /* Screens */
    .screen{display:none; padding:16px 16px 18px}
    .screen.active{display:block}

    /* Menu grid */
    .grid{
      display:grid;
      grid-template-columns: repeat(auto-fit, minmax(260px, 1fr));
      gap:12px;
      margin-top:10px;
    }
    .card{
      background:var(--card);
      border:2px solid var(--line);
      border-radius:18px;
      padding:14px;
      display:flex;
      flex-direction:column;
      gap:10px;
      min-height:168px;
    }
    .card h3{
      margin:0;
      color:#083344;
      font-size:16px;
      letter-spacing:.4px;
    }
    .card p{
      margin:0;
      font-size:12px;
      color:#075985;
      line-height:1.5;
      font-weight:700;
    }
    .row{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      align-items:center;
      justify-content:space-between;
      margin-top:auto;
    }

    /* Buttons */
    .btn{
      border:none;
      border-radius:14px;
      padding:12px 14px;
      font-weight:900;
      cursor:pointer;
      font-family: inherit;
      letter-spacing:.3px;
      transition: transform .08s ease, filter .12s ease;
      user-select:none;
    }
    .btn:hover{ filter:brightness(1.06) }
    .btn:active{ transform: translateY(1px) }
    .primary{ background: var(--brand); color:#fff; }
    .soft{ background:#ffffff; border:2px solid var(--line); color:#083344; }
    .disabled{ opacity:.55; cursor:not-allowed; }

    /* Game layout */
    .gameHeader{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      align-items:center;
      justify-content:space-between;
      margin-bottom:10px;
    }
    .pillRow{
      display:flex;
      gap:8px;
      flex-wrap:wrap;
      align-items:center;
    }
    .pill{
      background:#e0f2fe;
      border:2px solid var(--line);
      border-radius:999px;
      padding:9px 11px;
      font-size:11px;
      font-weight:900;
      color:#083344;
      white-space:nowrap;
    }
    .info{
      width:100%;
      background:#e0f2fe;
      border:2px solid var(--line);
      border-radius:16px;
      padding:10px 12px;
      font-size:12px;
      font-weight:800;
      color:#075985;
      line-height:1.35;
    }

    .gameWrap{
      display:grid;
      grid-template-columns: minmax(0, 1fr) 320px;
      gap:12px;
      align-items:start;
      margin-top:10px;
    }

    /* Board */
    .board{
      background:#030712;
      border:2px solid rgba(14,165,233,.9);
      border-radius:18px;
      padding:10px;
      display:grid;
      gap:4px;
      user-select:none;
    }

    .cell{
      border-radius:10px;
      display:flex;
      align-items:center;
      justify-content:center;
      text-align:center;
      line-height:1.05;
      font-weight:900;
      padding:4px;
      border:1px solid rgba(255,255,255,.08);
      background: rgba(14,165,233,.04);
      color: rgba(255,255,255,.92);
      position:relative;
      overflow:hidden;
    }

    /* BIGGER words */
    .cell.word{
      background: rgba(255,255,255,.07);
      border: 1px solid rgba(255,255,255,.22);
      color:#fff;
    }
    .cell.word.next{
      background: rgba(22,163,74,.18);
      border-color: rgba(22,163,74,.55);
    }

    .cell.wall{
      background: rgba(59,130,246,.18);
      border-color: rgba(59,130,246,.20);
    }

    /* Pac + Ghost */
    .cell.pac::before{
      content:"";
      width: 34px;
      height: 34px;
      background: #2563eb;
      border-radius: 50%;
      clip-path: polygon(50% 50%, 100% 25%, 100% 75%);
      transform: rotate(var(--rot, 0deg));
      position:absolute;
    }
    .cell.ghost::before{
      content:"";
      width: 32px;
      height: 34px;
      background: #facc15;
      border-radius: 16px 16px 9px 9px;
      position:absolute;
      box-shadow: inset 0 -5px 0 0 #f59e0b;
    }
    .cell.ghost::after{
      content:"‚Ä¢ ‚Ä¢";
      position:absolute;
      top:14px;
      color:#111827;
      font-size:13px;
      letter-spacing:2px;
      font-weight:900;
    }

    /* Side panel */
    .side{
      background: var(--card);
      border:2px solid var(--line);
      border-radius:18px;
      padding:12px;
    }
    .side h4{
      margin:0 0 10px;
      color:#083344;
      font-size:13px;
      letter-spacing:.6px;
      text-transform:uppercase;
    }
    .progressRow{
      display:flex;
      flex-wrap:wrap;
      gap:8px;
      margin:8px 0 10px;
    }
    .slot{
      min-width:40px;
      padding:10px 10px;
      border-radius:12px;
      border:1px dashed rgba(2,132,199,.35);
      background: rgba(255,255,255,.6);
      font-weight:1000;
      text-align:center;
      color: rgba(7,89,133,.75);
    }
    .slot.filled{
      border-style:solid;
      border-color: rgba(22,163,74,.45);
      background: rgba(22,163,74,.12);
      color:#083344;
    }

    .feedback{
      min-height:26px;
      font-size:12px;
      font-weight:1000;
      line-height:1.2;
      margin-top:8px;
      color:#075985;
    }
    .feedback.ok{ color: var(--ok); }
    .feedback.bad{ color: var(--bad); }
    .feedback.warn{ color: var(--warn); }

    .controls{
      display:grid;
      grid-template-columns: 1fr 1fr 1fr;
      gap:8px;
      max-width: 240px;
      margin-top:10px;
    }
    .controls .btn{ padding:10px 10px; border-radius:14px; }

    .miniRow{
      display:flex;
      gap:8px;
      flex-wrap:wrap;
      margin-top:10px;
    }

    .small{
      font-size:11px;
      color:#075985;
      font-weight:800;
      line-height:1.35;
      margin-top:10px;
    }

    /* Responsive */
    @media (max-width: 980px){
      .gameWrap{ grid-template-columns: 1fr; }
    }
  </style>
</head>

<body>
  <main class="app">
    <header class="topbar">
      <h1>THE PIT ‚Äî GAMES STATION</h1>
      <p class="sub">
        Men√∫ de juegos para estaciones. Empieza con <b>PacSentence</b> (come palabras y ordena frases).
        Sin mostrar el orden por adelantado.
      </p>
    </header>

    <!-- MENU -->
    <section id="menuScreen" class="screen active">
      <div class="grid">
        <article class="card">
          <h3>üü¶ PacSentence (Ordena frases)</h3>
          <p>
            Control con flechas o botones. Come palabras en el orden correcto.
            Palabras grandes y visibles. Sin pista del orden (solo progreso).
          </p>
          <div class="row">
            <button id="startPacBtn" class="btn primary">Abrir juego</button>
            <button id="menuHomeBtn" class="btn soft" onclick="location.href='../index.html'">Main Menu</button>
          </div>
        </article>

        <article class="card">
          <h3>üöß Pr√≥ximamente</h3>
          <p>Hueco para otros juegos (Quiz, Matching, Wheel‚Ä¶). Mantengo este archivo limpio y estable.</p>
          <div class="row">
            <button class="btn soft disabled" disabled>Bloqueado</button>
            <button class="btn soft disabled" disabled>Bloqueado</button>
          </div>
        </article>
      </div>
    </section>

    <!-- GAME -->
    <section id="pacScreen" class="screen">
      <div class="gameHeader">
        <div class="pillRow">
          <div class="pill">Tiempo: <span id="timer">00:00</span></div>
          <div class="pill">Vidas: <span id="lives">3</span></div>
          <div class="pill">Next word: <span id="nextWord">-</span></div>
          <div class="pill">Ghosts: <span id="ghostState">ON</span></div>
        </div>
        <div class="pillRow">
          <button id="backToMenu" class="btn soft">Volver</button>
          <button id="restartGame" class="btn soft">Reiniciar</button>
          <button id="nextSentence" class="btn primary">Siguiente frase</button>
        </div>
      </div>

      <div class="info" id="assignInfo">
        Juego: PacSentence ¬∑ Skill asignada autom√°ticamente: <b>Word order</b>
      </div>

      <div class="gameWrap">
        <div>
          <div id="board" class="board" aria-label="PacSentence board"></div>
          <p class="small">
            Teclado: <b>‚Üê ‚Üë ‚Üí ‚Üì</b> ¬∑ Tambi√©n puedes usar los botones. Objetivo: comer la palabra <b>verde</b> (la siguiente correcta).
          </p>
        </div>

        <aside class="side">
          <h4>Progreso (sin revelar la frase)</h4>
          <div id="progressRow" class="progressRow"></div>

          <div id="feedback" class="feedback">Pulsa ‚ÄúSiguiente frase‚Äù para empezar.</div>

          <div class="controls" aria-label="Controls">
            <span></span>
            <button class="btn soft" data-dir="up">‚Üë</button>
            <span></span>
            <button class="btn soft" data-dir="left">‚Üê</button>
            <button class="btn soft" data-dir="down">‚Üì</button>
            <button class="btn soft" data-dir="right">‚Üí</button>
          </div>

          <div class="miniRow">
            <button id="toggleGhosts" class="btn soft">Fantasmas: ON</button>
            <button id="toggleReveal" class="btn soft">Teacher reveal: OFF</button>
          </div>

          <div class="small">
            <b>Teacher notes:</b><br>
            ‚Ä¢ ‚ÄúTeacher reveal‚Äù muestra la frase completa solo en feedback (OFF por defecto).<br>
            ‚Ä¢ Edita el banco de frases dentro del c√≥digo: <b>SENTENCES</b>.
          </div>
        </aside>
      </div>
    </section>
  </main>

<script>
(() => {
  // =========================
  // EDIT YOUR BANK HERE
  // =========================
  const SENTENCES = [
    // Present Simple
    "I always do my homework at night.",
    "She doesn‚Äôt like coffee.",
    "Do they play football on Fridays?",
    "We don‚Äôt watch TV in the morning.",
    // Future
    "I will call you tonight.",
    "They are going to visit Madrid tomorrow.",
    // Conditionals
    "If it rains, we will stay at home.",
    "If you study, you will pass the test."
  ];

  // =========================
  // CONFIG (bigger words)
  // =========================
  const GRID = 10;           // 10x10 board
  const TILE_PX = 64;        // controls cell size (bigger = bigger words)
  const WALL_DENSITY = 0.12; // fewer walls = more playable

  // =========================
  // DOM
  // =========================
  const $ = (id) => document.getElementById(id);
  const screens = {
    menu: $("menuScreen"),
    pac: $("pacScreen")
  };

  const board = $("board");
  const feedback = $("feedback");
  const progressRow = $("progressRow");
  const timerEl = $("timer");
  const livesEl = $("lives");
  const nextWordEl = $("nextWord");
  const ghostStateEl = $("ghostState");
  const assignInfo = $("assignInfo");

  // =========================
  // STATE
  // =========================
  const state = {
    running: false,
    reveal: false,
    ghosts: true,

    grid: [],      // 0 empty, 1 wall
    words: [],     // {word, x, y, idx, eaten}
    tokens: [],
    expected: 0,

    pac: {x: 0, y: 0, dir: "right"},
    ghost: {x: GRID-1, y: GRID-1},

    lives: 3,
    seconds: 0,
    timerRef: null,
    ghostRef: null,

    currentSentence: ""
  };

  // =========================
  // UTIL
  // =========================
  function shuffle(arr){
    for (let i = arr.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random()*(i+1));
      [arr[i], arr[j]] = [arr[j], arr[i]];
    }
    return arr;
  }
  function pad2(n){ return String(n).padStart(2,"0"); }
  function setScreen(name){
    Object.values(screens).forEach(s => s.classList.remove("active"));
    screens[name].classList.add("active");
  }
  function setFB(msg, cls=""){
    feedback.className = "feedback" + (cls ? ` ${cls}` : "");
    feedback.textContent = msg;
  }
  function updateHUD(){
    timerEl.textContent = `${pad2(Math.floor(state.seconds/60))}:${pad2(state.seconds%60)}`;
    livesEl.textContent = String(state.lives);
    nextWordEl.textContent = state.tokens[state.expected] || "Done!";
    ghostStateEl.textContent = state.ghosts ? "ON" : "OFF";
  }
  function updateAssign(){
    const skills = ["Word order", "Grammar accuracy", "Sentence building"];
    const pick = skills[Math.floor(Math.random()*skills.length)];
    assignInfo.innerHTML = `Juego: PacSentence ¬∑ Skill asignada autom√°ticamente: <b>${pick}</b>`;
  }

  // =========================
  // GRID + PLACEMENT
  // =========================
  function buildGrid(){
    const g = Array.from({length: GRID}, () => Array(GRID).fill(0));

    // borders as walls
    for (let x=0; x<GRID; x++){ g[0][x]=1; g[GRID-1][x]=1; }
    for (let y=0; y<GRID; y++){ g[y][0]=1; g[y][GRID-1]=1; }

    // random walls inside
    for (let y=1; y<GRID-1; y++){
      for (let x=1; x<GRID-1; x++){
        if ((x===1 && y===1) || (x===GRID-2 && y===GRID-2)) continue;
        if (Math.random() < WALL_DENSITY) g[y][x]=1;
      }
    }

    // ensure start zones open
    for (let y=1; y<=2; y++){
      for (let x=1; x<=2; x++) g[y][x]=0;
    }
    for (let y=GRID-3; y<=GRID-2; y++){
      for (let x=GRID-3; x<=GRID-2; x++) g[y][x]=0;
    }

    state.grid = g;
  }

  function emptyCells(){
    const cells = [];
    for (let y=1; y<GRID-1; y++){
      for (let x=1; x<GRID-1; x++){
        if (state.grid[y][x] === 0) cells.push({x,y});
      }
    }
    return cells;
  }

  function placeWords(sentence){
    state.currentSentence = sentence;
    state.tokens = sentence.trim().split(/\s+/);
    state.expected = 0;

    // distractors (optional): pick from other sentences
    const pool = new Set();
    SENTENCES.forEach(s => {
      if (s === sentence) return;
      s.trim().split(/\s+/).forEach(w => pool.add(w));
    });
    const distractors = shuffle([...pool]).slice(0, 10);

    const items = state.tokens.map((w,i)=>({word:w, idx:i, isCorrect:true}))
      .concat(distractors.map(w=>({word:w, idx:-1, isCorrect:false})));

    shuffle(items);

    const cells = emptyCells().filter(c => !(c.x===1 && c.y===1) && !(c.x===GRID-2 && c.y===GRID-2));
    shuffle(cells);

    state.words = [];
    const count = Math.min(items.length, cells.length);
    for (let i=0; i<count; i++){
      state.words.push({
        word: items[i].word,
        idx: items[i].idx,
        isCorrect: items[i].isCorrect,
        eaten: false,
        x: cells[i].x,
        y: cells[i].y
      });
    }
  }

  // =========================
  // RENDER
  // =========================
  function buildProgress(){
    progressRow.innerHTML = "";
    for (let i=0; i<state.tokens.length; i++){
      const d = document.createElement("div");
      d.className = "slot" + (i < state.expected ? " filled" : "");
      d.textContent = (i < state.expected) ? "‚úì" : "_";
      progressRow.appendChild(d);
    }
  }

  function render(){
    board.style.gridTemplateColumns = `repeat(${GRID}, 1fr)`;
    board.style.gridAutoRows = `${TILE_PX}px`;

    board.innerHTML = "";
    for (let y=0; y<GRID; y++){
      for (let x=0; x<GRID; x++){
        const cell = document.createElement("div");
        cell.className = "cell";

        if (state.grid[y][x] === 1) cell.classList.add("wall");

        // word?
        const w = state.words.find(it => !it.eaten && it.x===x && it.y===y);
        if (w){
          cell.classList.add("word");

          // highlight ONLY the next correct word (still not revealing order list)
          if (w.isCorrect && w.idx === state.expected) cell.classList.add("next");

          // larger dynamic font fit
          const text = w.word;
          const maxChars = 9; // basic fit
          cell.textContent = text.length > 12 ? text.slice(0,12) : text;
          cell.style.fontSize = text.length <= maxChars ? "16px" : "13px";
        }

        // ghost
        if (state.ghosts && state.ghost.x===x && state.ghost.y===y){
          cell.classList.add("ghost");
          cell.textContent = "";
        }

        // pac
        if (state.pac.x===x && state.pac.y===y){
          cell.classList.add("pac");
          cell.textContent = "";
          const rot = {right:"0deg",down:"90deg",left:"180deg",up:"270deg"}[state.pac.dir] || "0deg";
          cell.style.setProperty("--rot", rot);
        }

        board.appendChild(cell);
      }
    }
  }

  // =========================
  // GAME LOGIC
  // =========================
  function stopLoops(){
    clearInterval(state.timerRef);
    clearInterval(state.ghostRef);
    state.timerRef = null;
    state.ghostRef = null;
  }

  function startLoops(){
    stopLoops();
    state.timerRef = setInterval(() => {
      if (!state.running) return;
      state.seconds++;
      updateHUD();
    }, 1000);

    state.ghostRef = setInterval(() => {
      if (!state.running) return;
      if (!state.ghosts) return;
      moveGhost();
      checkCollision();
      render();
    }, 700);
  }

  function resetPositions(){
    state.pac = {x:1, y:1, dir:"right"};
    state.ghost = {x:GRID-2, y:GRID-2};
  }

  function startGame(){
    updateAssign();
    buildGrid();
    resetPositions();

    state.seconds = 0;
    state.lives = 3;
    state.running = true;

    const s = SENTENCES[Math.floor(Math.random()*SENTENCES.length)];
    placeWords(s);

    buildProgress();
    updateHUD();
    render();
    setFB("Empieza: come la palabra verde (la siguiente correcta).", "ok");
    startLoops();
  }

  function nextSentence(){
    buildGrid();
    resetPositions();
    state.seconds = 0;
    state.running = true;

    const s = SENTENCES[Math.floor(Math.random()*SENTENCES.length)];
    placeWords(s);

    buildProgress();
    updateHUD();
    render();
    setFB("Nueva frase: empieza de nuevo. (Sin mostrar el orden).", "ok");
  }

  function move(dir){
    if (!state.running) return;

    const v = {up:[0,-1],down:[0,1],left:[-1,0],right:[1,0]}[dir];
    if (!v) return;

    state.pac.dir = dir;
    const nx = state.pac.x + v[0];
    const ny = state.pac.y + v[1];

    // wall check
    if (state.grid[ny]?.[nx] === 1) {
      render();
      return;
    }

    state.pac.x = nx;
    state.pac.y = ny;

    eatIfWord();
    checkCollision();

    render();
  }

  function eatIfWord(){
    const item = state.words.find(w => !w.eaten && w.x===state.pac.x && w.y===state.pac.y);
    if (!item) return;

    const expected = state.tokens[state.expected];

    // correct only if it is the next correct token
    if (item.isCorrect && item.idx === state.expected && item.word === expected){
      item.eaten = true;
      state.expected++;
      buildProgress();
      updateHUD();

      if (state.expected >= state.tokens.length){
        state.running = false;
        stopLoops();
        if (state.reveal){
          setFB(`üèÜ Completada: ${state.currentSentence}`, "ok");
        } else {
          setFB("üèÜ ¬°Frase completada! Pulsa ‚ÄúSiguiente frase‚Äù.", "ok");
        }
        return;
      }

      setFB("‚úÖ Correcto. Sigue con la palabra verde.", "ok");
      if (state.reveal) setFB(`‚úÖ Correcto. Frase: ${state.currentSentence}`, "warn");
    } else {
      // wrong word eaten
      item.eaten = true; // remove distractor or wrong token so it doesn't block
      state.lives--;
      updateHUD();

      if (state.lives <= 0){
        state.running = false;
        stopLoops();
        setFB("üíÄ Sin vidas. Pulsa Reiniciar.", "bad");
      } else {
        setFB(`‚ùå Incorrecto. Pierdes 1 vida. Next word sigue siendo: ${expected}`, "bad");
        if (state.reveal) setFB(`‚ùå Incorrecto. Frase: ${state.currentSentence}`, "warn");
      }
    }
  }

  function moveGhost(){
    // simple chase
    const dx = state.pac.x - state.ghost.x;
    const dy = state.pac.y - state.ghost.y;

    let stepX = 0, stepY = 0;
    if (Math.abs(dx) >= Math.abs(dy) && dx !== 0) stepX = Math.sign(dx);
    else if (dy !== 0) stepY = Math.sign(dy);

    // try preferred step, else random valid step
    const candidates = [
      {x: state.ghost.x + stepX, y: state.ghost.y + stepY},
      {x: state.ghost.x + Math.sign(dx), y: state.ghost.y},
      {x: state.ghost.x, y: state.ghost.y + Math.sign(dy)},
      {x: state.ghost.x + 1, y: state.ghost.y},
      {x: state.ghost.x - 1, y: state.ghost.y},
      {x: state.ghost.x, y: state.ghost.y + 1},
      {x: state.ghost.x, y: state.ghost.y - 1},
    ];

    for (const c of candidates){
      if (c.x<1 || c.y<1 || c.x>GRID-2 || c.y>GRID-2) continue;
      if (state.grid[c.y][c.x] === 1) continue;
      state.ghost.x = c.x;
      state.ghost.y = c.y;
      return;
    }
  }

  function checkCollision(){
    if (!state.running) return;
    if (!state.ghosts) return;

    if (state.pac.x === state.ghost.x && state.pac.y === state.ghost.y){
      state.lives--;
      updateHUD();

      if (state.lives <= 0){
        state.running = false;
        stopLoops();
        setFB("üëª Te atrap√≥ el fantasma. Game Over. Pulsa Reiniciar.", "bad");
      } else {
        // reset pac position only
        state.pac.x = 1; state.pac.y = 1; state.pac.dir = "right";
        setFB("üëª Fantasma: pierdes 1 vida. Vuelves al inicio.", "warn");
      }
    }
  }

  // =========================
  // EVENTS
  // =========================
  $("startPacBtn").addEventListener("click", () => {
    setScreen("pac");
    startGame();
  });

  $("backToMenu").addEventListener("click", () => {
    state.running = false;
    stopLoops();
    setScreen("menu");
  });

  $("restartGame").addEventListener("click", () => startGame());
  $("nextSentence").addEventListener("click", () => nextSentence());

  $("toggleGhosts").addEventListener("click", () => {
    state.ghosts = !state.ghosts;
    $("toggleGhosts").textContent = `Fantasmas: ${state.ghosts ? "ON" : "OFF"}`;
    updateHUD();
    render();
    setFB(state.ghosts ? "Fantasmas activados." : "Fantasmas desactivados.", "warn");
  });

  $("toggleReveal").addEventListener("click", () => {
    state.reveal = !state.reveal;
    $("toggleReveal").textContent = `Teacher reveal: ${state.reveal ? "ON" : "OFF"}`;
    setFB(state.reveal ? "Teacher reveal ON (la frase aparece en feedback)." : "Teacher reveal OFF.", "warn");
  });

  document.querySelectorAll("[data-dir]").forEach(btn => {
    btn.addEventListener("click", () => move(btn.dataset.dir));
  });

  window.addEventListener("keydown", (e) => {
    const map = {ArrowUp:"up", ArrowDown:"down", ArrowLeft:"left", ArrowRight:"right"};
    if (!map[e.key]) return;
    e.preventDefault();
    move(map[e.key]);
  });

  // Init
  setFB("Abre PacSentence desde el men√∫ para jugar.", "");
  updateHUD();
})();
</script>
</body>
</html>
